Skip to main content
PyCRAM - Home
Welcome to pycram’s documentation!
Getting Started

Installation
Concepts

ROS Utils
Adding a new robot to PyCRAM
Jupyter Notebook Examples
Designators
Knowledge
Knowledge and Reasoning
Costmaps
Trouble Shooting

Troubleshooting
General Remarks
Examples

PyCRAM Introduction
Bullet World
Plan Language
Local Transformer
TaskTree Tutorial
Improving Actions using Probabilities
Designators
ORM
Datastructure
External Interface
Knowledge Examples
Graph of Convex Sets
API

pycram
pycram.cache_manager
pycram.costmaps
pycram.datastructures
pycram.description
pycram.designator
pycram.designators
pycram.designators.action_designator
pycram.designators.location_designator
pycram.designators.motion_designator
pycram.designators.object_designator
pycram.designators.specialized_designators
pycram.external_interfaces
pycram.failure_handling
pycram.failures
pycram.filter
pycram.fluent
pycram.graph_of_convex_sets
pycram.helper
pycram.knowledge
pycram.language
pycram.local_transformer
pycram.object_descriptors
pycram.orm
pycram.pose_generator_and_validator
pycram.probabilistic_costmap
pycram.process_module
pycram.process_modules
pycram.robot_description
pycram.robot_descriptions
pycram.ros
pycram.ros_utils
pycram.tasktree
pycram.testing
pycram.tf_transformations
pycram.units
pycram.utils
pycram.validation
pycram.world_concepts
pycram.world_reasoning
pycram.worlds
pycram.designators.action_designator
Classes
ActionAbstract

Base class for performable performables.

MoveTorsoActionPerformable

Move the torso of the robot up and down.

SetGripperActionPerformable

Set the gripper state of the robot.

ReleaseActionPerformable

Releases an Object from the robot.

GripActionPerformable

Grip an object with the robot.

ParkArmsActionPerformable

Park the arms of the robot.

ReachToPickUpActionPerformable

Let the robot reach a specific pose.

PickUpActionPerformable

Let the robot pick up an object.

PlaceActionPerformable

Places an Object at a position using an arm.

NavigateActionPerformable

Navigates the Robot to a position.

TransportActionPerformable

Transports an object to a position using an arm

LookAtActionPerformable

Lets the robot look at a position.

DetectActionPerformable

Detects an object that fits the object description and returns an object designator_description describing the object.

OpenActionPerformable

Opens a container like object

CloseActionPerformable

Closes a container like object.

GraspingActionPerformable

Grasps an object described by the given Object Designator description

FaceAtPerformable

Turn the robot chassis such that is faces the pose and after that perform a look at action.

MoveAndPickUpPerformable

Navigate to standing_position, then turn towards the object and pick it up.

MoveAndPlacePerformable

Navigate to standing_position, then turn towards the object and pick it up.

PouringPerformable

Action class for the Pouring action.

MoveTorsoAction

Action Designator for Moving the torso of the robot up and down

SetGripperAction

Set the gripper state of the robot

ReleaseAction

Releases an Object from the robot.

GripAction

Grip an object with the robot.

ParkArmsAction

Park the arms of the robot.

PickUpAction

Designator to let the robot pick up an object.

PlaceAction

Places an Object at a position using an arm.

NavigateAction

Navigates the Robot to a position.

TransportAction

Transports an object to a position using an arm

LookAtAction

Lets the robot look at a position.

DetectAction

Detects an object that fits the object description and returns an object designator_description describing the object.

OpenAction

Opens a container like object

CloseAction

Closes a container like object.

GraspingAction

Grasps an object described by the given Object Designator description

PouringAction

Designator for pouring liquids from one container to another.

Functions
validate_close_open(object_designator, arm, action_type)

Validates if the container is opened or closed by checking the joint position of the container.

check_opened(joint_obj, obj_part, arm, upper_limit)

check_closed(joint_obj, obj_part, arm, lower_limit)

Module Contents
class pycram.designators.action_designator.ActionAbstract
Bases: pycram.designator.ActionDesignatorDescription.Action, abc.ABC

Base class for performable performables.

orm_class: typing_extensions.Type[pycram.orm.action_designator.Action] = None
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

abstract plan() → None
plan of the action.

Will be overwritten by each action.

to_sql() → pycram.orm.action_designator.Action
Convert this action to its ORM equivalent.

Needs to be overwritten by an action if it didn’t overwrite the orm_class attribute with its ORM equivalent.

Returns
:
An instance of the ORM equivalent of the action with the parameters set

insert(session: sqlalchemy.orm.Session, **kwargs) → pycram.orm.action_designator.Action
Insert this action into the database.

Needs to be overwritten by an action if the action has attributes that do not exist in the orm class equivalent. In that case, the attributes need to be inserted into the session manually.

Parameters
:
session – Session with a database that is used to add and commit the objects

kwargs – Possible extra keyword arguments

Returns
:
The completely instanced ORM action that was inserted into the database

__str__()
__repr__()
class pycram.designators.action_designator.MoveTorsoActionPerformable
Bases: ActionAbstract

Move the torso of the robot up and down.

joint_positions: typing_extensions.Dict[str, float]
The joint positions that should be set. The keys are the joint names and the values are the joint positions.

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: datetime.timedelta = timedelta(seconds=2))
Create a goal validator for the joint positions and wait until the goal is achieved or the timeout is reached.

class pycram.designators.action_designator.SetGripperActionPerformable
Bases: ActionAbstract

Set the gripper state of the robot.

gripper: pycram.datastructures.enums.Arms
The gripper that should be set

motion: pycram.datastructures.enums.GripperState
The motion that should be set on the gripper

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: datetime.timedelta = timedelta(seconds=2))
Needs gripper state to be read or perceived.

class pycram.designators.action_designator.ReleaseActionPerformable
Bases: ActionAbstract

Releases an Object from the robot.

Note: This action can not ve used yet.

gripper: pycram.datastructures.enums.Arms
object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
abstract plan() → None
plan of the action.

Will be overwritten by each action.

class pycram.designators.action_designator.GripActionPerformable
Bases: ActionAbstract

Grip an object with the robot.

Note: This action can not be used yet.

gripper: pycram.datastructures.enums.Arms
object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
effort: float
abstract plan() → None
plan of the action.

Will be overwritten by each action.

class pycram.designators.action_designator.ParkArmsActionPerformable
Bases: ActionAbstract

Park the arms of the robot.

arm: pycram.datastructures.enums.Arms
Entry from the enum for which arm should be parked

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

get_joint_poses() → typing_extensions.Dict[str, float]
Returns
:
The joint positions that should be set for the arm to be in the park position.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: datetime.timedelta = timedelta(seconds=2))
Create a goal validator for the joint positions and wait until the goal is achieved or the timeout is reached.

class pycram.designators.action_designator.ReachToPickUpActionPerformable
Bases: ActionAbstract

Let the robot reach a specific pose.

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
Object designator_description describing the object that should be picked up

arm: pycram.datastructures.enums.Arms
The arm that should be used for pick up

grasp: pycram.datastructures.enums.Grasp
The grasp that should be used. For example, ‘left’ or ‘right’

orm_object_at_execution: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription.Object]
The object at the time this Action got created. It is used to be a static, information holding entity. It is not updated when the BulletWorld object is changed.

prepose_distance: float
The distance in meters the gripper should be at before picking up the object

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

__post_init__()
plan() → None
plan of the action.

Will be overwritten by each action.

approach_target_pose(pose: pycram.datastructures.pose.Pose, add_vis_axis: bool = True)
Go to the target pose by moving in a straight line motion.

Parameters
:
pose – The pose to go to.

add_vis_axis – If a visual axis should be added to the world.

go_to_pose(pose: pycram.datastructures.pose.Pose, movement_type: pycram.datastructures.enums.MovementType = MovementType.CARTESIAN, add_vis_axis: bool = True)
Go to a specific pose.

Parameters
:
pose – The pose to go to.

movement_type – The type of movement that should be performed.

add_vis_axis – If a visual axis should be added to the world.

adjust_target_pose_to_grasp_type() → pycram.datastructures.pose.Pose
Adjust the target pose according to the grasp type by adjusting the orientation of the gripper.

Returns
:
The adjusted target pose.

calculate_pre_grasping_pose(obj_pose: pycram.datastructures.pose.Pose) → pycram.datastructures.pose.Pose
Calculate the pre grasping pose of the object depending on the gripper and the pre-pose distance.

Returns
:
The pre grasping pose of the object.

transform_to_gripper_frame(pose: pycram.datastructures.pose.Pose) → pycram.datastructures.pose.Pose
Transform a pose to the gripper frame.

Parameters
:
pose – The pose to transform.

Returns
:
The transformed pose.

transform_pose(pose: pycram.datastructures.pose.Pose, frame: str) → pycram.datastructures.pose.Pose
Transform a pose to a different frame.

Parameters
:
pose – The pose to transform.

frame – The frame to transform the pose to.

Returns
:
The transformed pose.

property local_transformer: pycram.local_transformer.LocalTransformer
property world_object: pycram.world_concepts.world_object.Object
property gripper_frame: str
property arm_chain: pycram.robot_description.KinematicChainDescription
to_sql() → pycram.orm.action_designator.Action
Convert this action to its ORM equivalent.

Needs to be overwritten by an action if it didn’t overwrite the orm_class attribute with its ORM equivalent.

Returns
:
An instance of the ORM equivalent of the action with the parameters set

insert(session: sqlalchemy.orm.Session, **kwargs) → pycram.orm.action_designator.Action
Insert this action into the database.

Needs to be overwritten by an action if the action has attributes that do not exist in the orm class equivalent. In that case, the attributes need to be inserted into the session manually.

Parameters
:
session – Session with a database that is used to add and commit the objects

kwargs – Possible extra keyword arguments

Returns
:
The completely instanced ORM action that was inserted into the database

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if object is contained in the gripper such that it can be grasped and picked up.

class pycram.designators.action_designator.PickUpActionPerformable
Bases: ActionAbstract

Let the robot pick up an object.

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
Object designator_description describing the object that should be picked up

arm: pycram.datastructures.enums.Arms
The arm that should be used for pick up

grasp: pycram.datastructures.enums.Grasp
The grasp that should be used. For example, ‘left’ or ‘right’

orm_object_at_execution: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription.Object]
The object at the time this Action got created. It is used to be a static, information holding entity. It is not updated when the BulletWorld object is changed.

prepose_distance: float
The distance in meters the gripper should be at before picking up the object

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

__post_init__()
plan() → None
plan of the action.

Will be overwritten by each action.

lift_object(distance: float = 0.1)
gripper_pose() → pycram.datastructures.pose.Pose
Get the pose of the gripper.

Returns
:
The pose of the gripper.

to_sql() → pycram.orm.action_designator.Action
Convert this action to its ORM equivalent.

Needs to be overwritten by an action if it didn’t overwrite the orm_class attribute with its ORM equivalent.

Returns
:
An instance of the ORM equivalent of the action with the parameters set

insert(session: sqlalchemy.orm.Session, **kwargs) → pycram.orm.action_designator.Action
Insert this action into the database.

Needs to be overwritten by an action if the action has attributes that do not exist in the orm class equivalent. In that case, the attributes need to be inserted into the session manually.

Parameters
:
session – Session with a database that is used to add and commit the objects

kwargs – Possible extra keyword arguments

Returns
:
The completely instanced ORM action that was inserted into the database

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if picked up object is in contact with the gripper.

property arm_chain: pycram.robot_description.KinematicChainDescription
property world_object: pycram.world_concepts.world_object.Object
class pycram.designators.action_designator.PlaceActionPerformable
Bases: ActionAbstract

Places an Object at a position using an arm.

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
Object designator_description describing the object that should be place

arm: pycram.datastructures.enums.Arms
Arm that is currently holding the object

target_location: pycram.datastructures.pose.Pose
Pose in the world at which the object should be placed

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

calculate_target_pose_of_gripper()
Calculate the target pose of the gripper given the target pose of the held object. wTg (world to gripper) = wTo (world to object target) * oTg (object to gripper, this is constant since object is attached to the gripper)

calculate_retract_pose(target_pose: pycram.datastructures.pose.Pose, distance: float) → pycram.datastructures.pose.Pose
Calculate the retract pose of the gripper.

Parameters
:
target_pose – The target pose of the gripper.

distance – The distance the gripper should be retracted.

property world_object: pycram.world_concepts.world_object.Object
property gripper_pose: pycram.datastructures.pose.Pose
Get the pose of the gripper.

Returns
:
The pose of the gripper.

property gripper_tool_frame: str
property gripper_link: pycram.description.Link
property arm_chain: pycram.robot_description.KinematicChainDescription
property local_transformer: pycram.local_transformer.LocalTransformer
validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if the object is placed at the target location.

validate_loss_of_contact()
Check if the object is still in contact with the robot after placing it.

validate_placement_location()
Check if the object is placed at the target location.

class pycram.designators.action_designator.NavigateActionPerformable
Bases: ActionAbstract

Navigates the Robot to a position.

target_location: pycram.datastructures.pose.Pose
Location to which the robot should be navigated

keep_joint_states: bool
Keep the joint states of the robot the same during the navigation.

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.TransportActionPerformable
Bases: ActionAbstract

Transports an object to a position using an arm

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
Object designator_description describing the object that should be transported.

target_location: pycram.datastructures.pose.Pose
Target Location to which the object should be transported

arm: pycram.datastructures.enums.Arms
Arm that should be used

pickup_prepose_distance: float
Distance between the object and the gripper in the x-axis before picking up the object.

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.LookAtActionPerformable
Bases: ActionAbstract

Lets the robot look at a position.

target: pycram.datastructures.pose.Pose
Position at which the robot should look, given as 6D pose

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if the robot is looking at the target location by spawning a virtual object at the target location and creating a ray from the camera and checking if it intersects with the object.

class pycram.designators.action_designator.DetectActionPerformable
Bases: ActionAbstract

Detects an object that fits the object description and returns an object designator_description describing the object.

If no object is found, an PerceptionObjectNotFound error is raised.

technique: pycram.datastructures.enums.DetectionTechnique
The technique that should be used for detection

state: pycram.datastructures.enums.DetectionState
The state of the detection, e.g Start Stop for continues perception

object_designator_description: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription] = None
The type of the object that should be detected, only considered if technique is equal to Type

region: typing_extensions.Optional[pycrap.ontologies.Location] = None
The region in which the object should be detected

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

orm_object_at_execution: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription.Object]
plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.OpenActionPerformable
Bases: ActionAbstract

Opens a container like object

object_designator: pycram.designators.object_designator.ObjectPart.Object
Object designator_description describing the object that should be opened

arm: pycram.datastructures.enums.Arms
Arm that should be used for opening the container

grasping_prepose_distance: float
The distance in meters the gripper should be at in the x-axis away from the handle.

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if the container is opened, this assumes that the container state can be read accurately from the real world.

class pycram.designators.action_designator.CloseActionPerformable
Bases: ActionAbstract

Closes a container like object.

object_designator: pycram.designators.object_designator.ObjectPart.Object
Object designator_description describing the object that should be closed

arm: pycram.datastructures.enums.Arms
Arm that should be used for closing

grasping_prepose_distance: float
The distance in meters between the gripper and the handle before approaching to grasp.

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Check if the container is closed, this assumes that the container state can be read accurately from the real world.

pycram.designators.action_designator.validate_close_open(object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object, arm: pycram.datastructures.enums.Arms, action_type: typing_extensions.Union[OpenActionPerformable, CloseActionPerformable])
Validates if the container is opened or closed by checking the joint position of the container.

Parameters
:
object_designator – The object designator_description describing the object that should be opened or closed.

arm – The arm that should be used for opening or closing the container.

action_type – The type of the action that should be validated.

pycram.designators.action_designator.check_opened(joint_obj: pycram.description.Joint, obj_part: pycram.description.Link, arm: pycram.datastructures.enums.Arms, upper_limit: float)
pycram.designators.action_designator.check_closed(joint_obj: pycram.description.Joint, obj_part: pycram.description.Link, arm: pycram.datastructures.enums.Arms, lower_limit: float)
class pycram.designators.action_designator.GraspingActionPerformable
Bases: ActionAbstract

Grasps an object described by the given Object Designator description

arm: pycram.datastructures.enums.Arms
The arm that should be used to grasp

object_desig: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription.Object, pycram.designators.object_designator.ObjectPart.Object]
Object Designator for the object that should be grasped

prepose_distance: float
The distance in meters the gripper should be at before grasping the object

orm_class: typing_extensions.Type[ActionAbstract]
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.FaceAtPerformable
Bases: ActionAbstract

Turn the robot chassis such that is faces the pose and after that perform a look at action.

pose: pycram.datastructures.pose.Pose
The pose to face

keep_joint_states: bool
Keep the joint states of the robot the same during the navigation.

orm_class
The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to be able to insert the action into the database.

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.MoveAndPickUpPerformable
Bases: ActionAbstract

Navigate to standing_position, then turn towards the object and pick it up.

standing_position: pycram.datastructures.pose.Pose
The pose to stand before trying to pick up the object

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
The object to pick up

arm: pycram.datastructures.enums.Arms
The arm to use

grasp: pycram.datastructures.enums.Grasp
The grasp to use

keep_joint_states: bool
Keep the joint states of the robot the same during the navigation.

pick_up_prepose_distance: float
The distance in meters the gripper should be at before picking up the object

plan()
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.MoveAndPlacePerformable
Bases: ActionAbstract

Navigate to standing_position, then turn towards the object and pick it up.

standing_position: pycram.datastructures.pose.Pose
The pose to stand before trying to pick up the object

object_designator: pycram.designators.object_designator.ObjectDesignatorDescription.Object
The object to pick up

target_location: pycram.datastructures.pose.Pose
The location to place the object.

arm: pycram.datastructures.enums.Arms
The arm to use

keep_joint_states: bool
Keep the joint states of the robot the same during the navigation.

plan()
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.PouringPerformable
Bases: ActionAbstract

Action class for the Pouring action.

object_: pycram.designators.object_designator.ObjectDesignatorDescription
The object to be poured into.

tool: pycram.designators.object_designator.ObjectDesignatorDescription
The tool used for pouring.

arm: pycram.datastructures.enums.Arms
The robot arm designated for the pouring task.

technique: typing_extensions.Optional[str] = None
The technique used for pouring (default is None).

angle: typing_extensions.Optional[float] = 90
The angle of the pouring action (default is 90).

plan() → None
plan of the action.

Will be overwritten by each action.

validate(result: typing_extensions.Optional[typing_extensions.Any] = None, max_wait_time: typing_extensions.Optional[datetime.timedelta] = None)
Validate the action after performing it, by checking if the action effects are as expected.

Parameters
:
result – The result of the action if there is any

max_wait_time – The maximum time to wait for the action to be validated, before raising an error.

class pycram.designators.action_designator.MoveTorsoAction(torso_states: typing_extensions.List[pycram.datastructures.enums.TorsoState])
Bases: pycram.designator.ActionDesignatorDescription

Action Designator for Moving the torso of the robot up and down

performable_class
Reference to the performable class that is used to execute the action.

torso_states: typing_extensions.List[pycram.datastructures.enums.TorsoState]
ground() → MoveTorsoActionPerformable
Creates a performable action designator_description with the first element from the list of possible torso heights.

Returns
:
A performable action designator_description

__iter__()
Iterates over all possible values for this designator_description and returns a performable action designator_description with the value.

Returns
:
A performable action designator_description

class pycram.designators.action_designator.SetGripperAction(grippers: typing_extensions.List[pycram.datastructures.enums.Arms], motions: typing_extensions.List[pycram.datastructures.enums.GripperState])
Bases: pycram.designator.ActionDesignatorDescription

Set the gripper state of the robot

performable_class
Reference to the performable class that is used to execute the action.

grippers: typing_extensions.List[pycram.datastructures.enums.Arms]
motions: typing_extensions.List[pycram.datastructures.enums.GripperState]
ground() → SetGripperActionPerformable
Default specialized_designators that returns a performable designator_description with the first element in the grippers and motions list.

Returns
:
A performable designator_description

__iter__()
Iterates over all possible combinations of grippers and motions

Returns
:
A performable designator_description with a combination of gripper and motion

class pycram.designators.action_designator.ReleaseAction(object_designator_description: pycram.designators.object_designator.ObjectDesignatorDescription, grippers: typing_extensions.List[pycram.datastructures.enums.Arms] = None)
Bases: pycram.designator.ActionDesignatorDescription

Releases an Object from the robot.

Note: This action can not be used yet.

performable_class
Reference to the performable class that is used to execute the action.

grippers: typing_extensions.List[pycram.datastructures.enums.Arms] = None
object_designator_description
ground() → ReleaseActionPerformable
Should be overwritten with an actual grounding function which infers missing properties.

__iter__()
Iterate through all possible performables fitting this description

Yield
:
A resolved action designator

class pycram.designators.action_designator.GripAction(object_designator_description: pycram.designators.object_designator.ObjectDesignatorDescription, grippers: typing_extensions.List[pycram.datastructures.enums.Arms] = None, efforts: typing_extensions.List[float] = None)
Bases: pycram.designator.ActionDesignatorDescription

Grip an object with the robot.

Variables
:
grippers – The grippers to consider

object_designator_description – The description of objects to consider

efforts – The efforts to consider

Note: This action can not be used yet.

performable_class
Reference to the performable class that is used to execute the action.

grippers: typing_extensions.List[pycram.datastructures.enums.Arms] = None
object_designator_description: pycram.designators.object_designator.ObjectDesignatorDescription
efforts: typing_extensions.List[float] = None
ground() → GripActionPerformable
Should be overwritten with an actual grounding function which infers missing properties.

__iter__()
Iterate through all possible performables fitting this description

Yield
:
A resolved action designator

class pycram.designators.action_designator.ParkArmsAction(arms: typing_extensions.List[pycram.datastructures.enums.Arms])
Bases: pycram.designator.ActionDesignatorDescription

Park the arms of the robot.

performable_class
Reference to the performable class that is used to execute the action.

arms: typing_extensions.List[pycram.datastructures.enums.Arms]
ground() → ParkArmsActionPerformable
Default specialized_designators that returns a performable designator_description with the first element of the list of possible arms

Returns
:
A performable designator_description

__iter__() → ParkArmsActionPerformable
Iterates over all possible solutions and returns a performable designator with the arm.

Returns
:
A performable designator_description

class pycram.designators.action_designator.PickUpAction(object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object], arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None, grasps: typing_extensions.List[pycram.datastructures.enums.Grasp] = None, prepose_distance: float = 0.03)
Bases: pycram.designator.ActionDesignatorDescription

Designator to let the robot pick up an object.

performable_class
Reference to the performable class that is used to execute the action.

object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object]
arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
grasps: typing_extensions.List[pycram.datastructures.enums.Grasp] = None
prepose_distance: float = 0.03
knowledge_condition
Knowledge condition that have to be fulfilled before executing the action.

__iter__() → PickUpActionPerformable
Iterate through all possible performables fitting this description

Yield
:
A resolved action designator

class pycram.designators.action_designator.PlaceAction(object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object], target_locations: typing_extensions.List[pycram.datastructures.pose.Pose], arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None)
Bases: pycram.designator.ActionDesignatorDescription

Places an Object at a position using an arm.

performable_class
Reference to the performable class that is used to execute the action.

object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object]
target_locations: typing_extensions.List[pycram.datastructures.pose.Pose]
arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
knowledge_condition
Knowledge condition that have to be fulfilled before executing the action.

ground() → PlaceActionPerformable
Default specialized_designators that returns a performable designator_description with the first entries from the list of possible entries.

Returns
:
A performable designator_description

__iter__() → PlaceActionPerformable
Iterate through all possible performables fitting this description

Yield
:
A resolved action designator

class pycram.designators.action_designator.NavigateAction(target_locations: typing_extensions.List[pycram.datastructures.pose.Pose], keep_joint_states: bool = False)
Bases: pycram.designator.ActionDesignatorDescription

Navigates the Robot to a position.

performable_class
Reference to the performable class that is used to execute the action.

target_locations: typing_extensions.List[pycram.datastructures.pose.Pose]
keep_joint_states: bool = False
ground() → NavigateActionPerformable
Default specialized_designators that returns a performable designator_description with the first entry of possible target locations.

Returns
:
A performable designator_description

__iter__() → NavigateActionPerformable
Iterates over all possible target locations

Returns
:
A performable designator_description

class pycram.designators.action_designator.TransportAction(object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object], target_locations: typing_extensions.List[pycram.datastructures.pose.Pose], arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None, pickup_prepose_distance: float = 0.03)
Bases: pycram.designator.ActionDesignatorDescription

Transports an object to a position using an arm

performable_class
Reference to the performable class that is used to execute the action.

object_designator_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectDesignatorDescription.Object]
arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
target_locations: typing_extensions.List[pycram.datastructures.pose.Pose]
pickup_prepose_distance: float = 0.03
ground() → TransportActionPerformable
Default specialized_designators that returns a performable designator_description with the first entries from the lists of possible parameter.

Returns
:
A performable designator_description

__iter__() → TransportActionPerformable
Iterate through all possible performables fitting this description

Yield
:
A resolved action designator

class pycram.designators.action_designator.LookAtAction(targets: typing_extensions.List[pycram.datastructures.pose.Pose])
Bases: pycram.designator.ActionDesignatorDescription

Lets the robot look at a position.

performable_class
Reference to the performable class that is used to execute the action.

targets: typing_extensions.List[pycram.datastructures.pose.Pose]
ground() → LookAtActionPerformable
Default specialized_designators that returns a performable designator_description with the first entry in the list of possible targets

Returns
:
A performable designator_description

__iter__() → LookAtActionPerformable
Iterates over all possible target locations

Returns
:
A performable designator_description

class pycram.designators.action_designator.DetectAction(technique: pycram.datastructures.enums.DetectionTechnique, state: typing_extensions.Optional[pycram.datastructures.enums.DetectionState] = None, object_designator_description: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription] = None, region: typing_extensions.Optional[pycrap.ontologies.Location] = None)
Bases: pycram.designator.ActionDesignatorDescription

Detects an object that fits the object description and returns an object designator_description describing the object.

performable_class
Reference to the performable class that is used to execute the action.

technique: pycram.datastructures.enums.DetectionTechnique
state: pycram.datastructures.enums.DetectionState
object_designator_description: typing_extensions.Optional[pycram.designators.object_designator.ObjectDesignatorDescription] = None
region: typing_extensions.Optional[pycrap.ontologies.Location] = None
ground() → DetectActionPerformable
Default specialized_designators that returns a performable designator_description with the executed object description.

Returns
:
A performable designator_description

__iter__() → DetectActionPerformable
Iterates over all possible values for this designator_description and returns a performable action designator_description with the value.

Returns
:
A performable action designator_description

class pycram.designators.action_designator.OpenAction(object_designator_description: pycram.designators.object_designator.ObjectPart, arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None, grasping_prepose_distance: float = 0.03)
Bases: pycram.designator.ActionDesignatorDescription

Opens a container like object

Can currently not be used

performable_class
Reference to the performable class that is used to execute the action.

object_designator_description: pycram.designators.object_designator.ObjectPart
arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
grasping_prepose_distance: float = 0.03
knowledge_condition
Knowledge condition that have to be fulfilled before executing the action.

ground() → OpenActionPerformable
Default specialized_designators that returns a performable designator_description with the executed object description and the first entries from the lists of possible parameter.

Returns
:
A performable designator_description

__iter__() → OpenActionPerformable
Iterates over all possible values for this designator_description and returns a performable action designator_description with the value.

Returns
:
A performable action designator_description

class pycram.designators.action_designator.CloseAction(object_designator_description: pycram.designators.object_designator.ObjectPart, arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None, grasping_prepose_distance: float = 0.03)
Bases: pycram.designator.ActionDesignatorDescription

Closes a container like object.

Can currently not be used

performable_class
Reference to the performable class that is used to execute the action.

object_designator_description: pycram.designators.object_designator.ObjectPart
arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
grasping_prepose_distance: float = 0.03
knowledge_condition
Knowledge condition that have to be fulfilled before executing the action.

ground() → CloseActionPerformable
Default specialized_designators that returns a performable designator_description with the executed object designator_description and the first entry from the list of possible arms.

Returns
:
A performable designator_description

__iter__() → CloseActionPerformable
Iterates over all possible solutions for this designator_description and returns a performable action designator.

Yield
:
A performable fully parametrized Action designator

class pycram.designators.action_designator.GraspingAction(object_description: typing_extensions.Union[pycram.designators.object_designator.ObjectDesignatorDescription, pycram.designators.object_designator.ObjectPart], arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None, prepose_distance: float = 0.03)
Bases: pycram.designator.ActionDesignatorDescription

Grasps an object described by the given Object Designator description

performable_class
Reference to the performable class that is used to execute the action.

arms: typing_extensions.List[pycram.datastructures.enums.Arms] = None
object_description: pycram.designators.object_designator.ObjectDesignatorDescription
prepose_distance: float = 0.03
ground() → GraspingActionPerformable
Default specialized_designators that takes the first element from the list of arms and the first solution for the object designator_description description ond returns it.

Returns
:
A performable action designator_description that contains specific arguments

__iter__() → CloseActionPerformable
Iterates over all possible solutions for this designator_description and returns a performable action designator.

Yield
:
A fully parametrized Action designator

class pycram.designators.action_designator.PouringAction(object_: pycram.designators.object_designator.ObjectDesignatorDescription, tool: pycram.designators.object_designator.ObjectDesignatorDescription, arms: typing_extensions.List[pycram.datastructures.enums.Arms], technique: typing_extensions.Optional[str] = None, angle: typing_extensions.Optional[float] = 90)
Bases: pycram.designator.ActionDesignatorDescription

Designator for pouring liquids from one container to another.

object_: pycram.designators.object_designator.ObjectDesignatorDescription
tool: pycram.designators.object_designator.ObjectDesignatorDescription
arms: typing_extensions.List[pycram.datastructures.enums.Arms]
technique: typing_extensions.Optional[str] = None
angle: typing_extensions.Optional[float] = 90
ground() → PouringPerformable
Default resolver, returns a performable designator with the first entries from the lists of possible parameter.

Returns
:
A performable designator

__iter__() → PouringPerformable
Iterates over all possible values for this designator_description and returns a performable action designator_description with the value.

Returns
:
A performable action designator_description

previous

pycram.designators

next

pycram.designators.location_designator

Contents
Classes
Functions
Module Contents
By Jonas Dech

© Copyright 2024.

Read the Docs
 latest